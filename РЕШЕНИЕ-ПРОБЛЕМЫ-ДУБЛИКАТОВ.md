# Решение проблемы дубликатов в message_links

## Проблема

При сохранении сообщений пользователя в `message_links` создавались **дубликаты** - одно и то же сообщение сохранялось в несколько разных постов.

### Пример:
Сообщение `message_id=6071` было записано ДВАЖДЫ:
- В пост 722 (вечерний, `state="schema_waiting_emotions"`)
- В пост 727 (утренний, `state=null`)

### Последствия:
1. Одно сообщение учитывалось дважды в разных событиях
2. Batch processor обрабатывал одно сообщение несколько раз
3. События (positive_events/negative_events) содержали дублированные данные

### Статистика:
- Всего записей в message_links: 2948
- Уникальных message_id: 2073
- **Дубликатов: 259** (8.8%)

## Причина

### Старая логика определения контекста (НЕПРАВИЛЬНО):

```typescript
1. Проверить replyToMessageId
2. Проверить последний незавершенный пост ← СЛИШКОМ РАНО!
3. Проверить messageThreadId (вечерний)
4. Проверить messageThreadId (утренний)
```

### Проблемная ситуация:

Пользователь имеет:
- Незавершенный вечерний пост 722
- Утренний пост 727

Пользователь пишет **В ТРЕДЕ утреннего поста** (messageThreadId = 727):

**Что происходило:**
1. Нет replyToMessageId → пропускаем
2. Есть незавершенный пост 722 → **сохраняем в 722** ✅
3. Проверяем messageThreadId = 727 → **сохраняем в 727** ✅
4. **РЕЗУЛЬТАТ: ДУБЛИКАТ!** ❌

## Решение

### Исправленная логика (ПРАВИЛЬНО):

```typescript
1. Проверить replyToMessageId (самый точный)
2. Проверить messageThreadId (точный, пользователь в конкретном треде) ← ПРИОРИТЕТ!
3. Проверить последний незавершенный пост (fallback)
```

### Изменения в коде:

**Файл:** `src/interactive-tracker.ts`

**Было:**
- Блок 2: Поиск последнего незавершенного поста
- Блок 3: Проверка messageThreadId (вечерний)
- Блок 4: Проверка messageThreadId (утренний)

**Стало:**
- Блок 2: Проверка messageThreadId (утренний + вечерний) ← ПЕРЕМЕСТИЛИ ВВЕРХ!
- Блок 3: Поиск последнего незавершенного поста (fallback)

### Теперь в проблемной ситуации:

Пользователь пишет **В ТРЕДЕ утреннего поста** (messageThreadId = 727):

**Что происходит:**
1. Нет replyToMessageId → пропускаем
2. Есть messageThreadId = 727 → **проверяем утренние посты** → находим пост 727 → **сохраняем в 727** → **ВОЗВРАЩАЕМ CONTEXT** ✅
3. Блок 3 НЕ выполняется (context уже установлен)
4. **РЕЗУЛЬТАТ: Сообщение только в 727!** ✅ НЕТ ДУБЛИКАТА!

## Результаты

### До исправления:
- Дубликаты создавались регулярно
- Сообщения попадали в несколько постов
- События содержали дублированные данные

### После исправления:
- **НОВЫЕ сообщения** НЕ создают дубликаты ✅
- Каждое сообщение сохраняется только в ОДИН правильный пост ✅
- Batch processor обрабатывает каждое сообщение только один раз ✅

### Старые дубликаты:
- Остаются в БД (созданы до исправления)
- Не влияют на новую логику
- Можно очистить отдельной миграцией (опционально)

## Тестирование

### Созданные тесты:
1. `test-context-priority.ts` - проверка отсутствия дубликатов между постами
2. `test-track-user-message-logic.ts` - интеграционный тест логики
3. `check-duplicate-impact.ts` - анализ влияния дубликатов на batch processor

### Результаты тестов:
✅ Между новыми постами НЕТ дубликатов
✅ Логика определения контекста работает правильно
✅ messageThreadId имеет приоритет над fallback

## Выводы

1. **Корректное решение** - исправление логики приоритетов, а не добавление проверок на дубликаты
2. **messageThreadId** - самый точный способ после replyToMessageId
3. **Fallback** на последний незавершенный пост - только когда нет ни реплая, ни треда
4. **Сообщения в messages** - сохраняются корректно (не было проблемы с дубликатами там)
5. **message_links** - теперь работает правильно, каждое сообщение в одном посте

## Что НЕ было сделано

- ❌ Добавление проверки на дубликаты в saveUserMessageLink (костыль)
- ❌ Очистка старых дубликатов из БД (не критично)
- ❌ Добавление UNIQUE constraint на message_links (может быть полезно)

## Рекомендации

1. Мониторить новые сообщения на предмет дубликатов
2. При желании добавить UNIQUE constraint на (message_id, user_id) в message_links
3. Рассмотреть очистку старых дубликатов (опционально)
